<!DOCTYPE html>
<html lang="en">
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebRTC Client</title>
    <style>
        canvas {
            border: 1px solid black;
        }
        #objectList {
            border: 1px solid #ccc;
            padding: 10px;
            margin-top: 20px;
        }
        #objectList div {
            margin-bottom: 10px;
        }
        #objectList label {
            display: block;
        }
    </style>
</head>
<body>
    <h1>WebSocket Client</h1>
    <p id="audioStatus">Audio status: Not connected</p>
    <img id="streamImage" alt="Streaming Image" />
    <audio id="remoteAudio" autoplay controls></audio>

    <div id="objectList"></div>
    <button id="saveButton">Guardar</button>

    <canvas id="audioCanvas" width="640" height="100"></canvas>

    <script>
        const API_TOKEN = '5ef80cb242d19e29cc3b5330bff2d632c73a21c2'; // Reemplaza con tu token real

        const socket = new WebSocket('ws://localhost:8000/ws/jsonScene/');
        let peerConnection;
        let localStream;
        let audioTrack;
        let projectData = {};
        const config = {
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        };

        async function start() {
            fetchData()
            try {
                // Request access to the microphone
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                document.getElementById('audioStatus').innerText = "Microphone access granted";

                // Create peer connection and add local stream
                createPeerConnection();
                audioTrack = localStream.getAudioTracks()[0];
                peerConnection.addTrack(audioTrack, localStream);
                visualizeAudio(localStream);
                
            } catch (err) {
                console.error('Error accessing media devices.', err);
                document.getElementById('audioStatus').innerText = "Microphone access denied";
            }
        }
// #region Canva Audio
        function visualizeAudio(stream) {
            const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            const source = audioCtx.createMediaStreamSource(stream);
            const analyser = audioCtx.createAnalyser();
            analyser.fftSize = 2048;
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            source.connect(analyser);

            const canvas = document.getElementById('audioCanvas');
            const canvasCtx = canvas.getContext('2d');

            function draw() {
                requestAnimationFrame(draw);

                analyser.getByteTimeDomainData(dataArray);

                canvasCtx.fillStyle = 'rgb(200, 200, 200)';
                canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

                canvasCtx.lineWidth = 2;
                canvasCtx.strokeStyle = 'rgb(0, 0, 0)';

                canvasCtx.beginPath();

                const sliceWidth = canvas.width * 1.0 / bufferLength;
                let x = 0;

                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * canvas.height / 2;

                    if (i === 0) {
                        canvasCtx.moveTo(x, y);
                    } else {
                        canvasCtx.lineTo(x, y);
                    }

                    x += sliceWidth;
                }

                canvasCtx.lineTo(canvas.width, canvas.height / 2);
                canvasCtx.stroke();
            }

            draw();
        }
// #endregion

// #region FetchData
        async function fetchData() {
            console.log("accesing data...")
            try {
                const url = 'https://projectvertexscape.onrender.com/api/proyectos/13/';
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'Authorization': `Token ${API_TOKEN}`
                    }
                });
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                const data = await response.json();
                console.log('API Data:', data); // Log the data obtained from the API
                
                // Almacenar los datos del proyecto en la variable global
                projectData.id = data.id;
                projectData.habitacion = data.unityproyect.habitacion;
                projectData.material_pared = data.unityproyect.material_pared;
                projectData.material_piso = data.unityproyect.material_piso;
                
                // Fetch para objeto
                const Objecturl = data.unityproyect.objeto; // Usar el URL almacenado en la variable objeto
                console.log("Objecturl: ", Objecturl);
                try {
                    const response = await fetch(Objecturl, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json'
                        }
                    });
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    const objetoData = await response.json();
                    console.log('Objeto Data:', objetoData); // Log the data obtained from the objeto URL

                    // Accede a la propiedad 'data' que contiene el array de objetos y almacenar en la variable global
                    projectData.objeto = objetoData.data;

                    // Fetch para habitacion
                    const HabitacionUrl = data.unityproyect.habitacion;
                    console.log("Habitacionurl: ", HabitacionUrl);
                    const habitacionResponse = await fetch(HabitacionUrl, {
                        method: 'GET',
                        headers: {
                            'Accept': 'application/json'
                        }
                    });
                    if (!habitacionResponse.ok) {
                        throw new Error('Network response was not ok');
                    }
                    const habitacionData = await habitacionResponse.json();
                    console.log('Habitacion Data:', habitacionData); // Log the data obtained from the habitacion URL

                    // Almacenar los datos de habitacion en la variable global
                    projectData.habitacion = habitacionData;

                    displayObjectList(projectData.objeto);
                } catch (error) {
                    console.error('Error fetching data:', error);
                }
            } catch (error) {
                console.error('Error fetching data:', error);
            }
        }

        function displayObjectList(data) {
            console.log('Display Object List Data:', data); // Log the data passed to displayObjectList
            const objectList = document.getElementById('objectList');
            objectList.innerHTML = '';

            // Accede a la propiedad 'data' que contiene el array de objetos
            // const objects = data.data;

            data.forEach((obj, index) => {
                const div = document.createElement('div');
                div.innerHTML = `
                    <label>${obj.prefabName}</label>
                    <input type="text" id="text-${index}" value="${obj.textContent || ''}" />
                `;
                objectList.appendChild(div);
            });
        }


        async function saveData() {
            const objectList = document.getElementById('objectList');
            const inputs = objectList.getElementsByTagName('input');
        
        //colocar texto en cada objeto
        for (let i = 0; i < inputs.length; i++) {
            // console.log(`Processing input ${i}, value: ${inputs[i].value}`);
            if (projectData.objeto[i]) {
                // console.log(`Before: ${JSON.stringify(projectData.objeto[i])}`);
                projectData.objeto[i].textContent = inputs[i].value || projectData.objeto[i].textContent;
                // console.log(`After: ${JSON.stringify(projectData.objeto[i])}`);
            } else {
                console.warn(`projectData.objeto[${i}] is undefined`);
            }
        }
            
            const projectDataToSend = {
                id: projectData.id,
                habitacion: projectData.habitacion,
                objeto: projectData.objeto,
                material_piso: projectData.material_piso,
                material_pared: projectData.material_pared
            };

            console.log("Request JSON:", JSON.stringify(projectDataToSend)); // Log para depuración

            try {
                const response = await fetch('https://projectvertexscape.onrender.com/api/unity-proyecto/', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Token ${API_TOKEN}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(projectData)
                });

                if (response.ok) {
                    alert('Data saved successfully');
                    // Aquí, puedes enviar un mensaje WebSocket si es necesario
                } else {
                    alert('Failed to save data');
                }
            } catch (error) {
                console.error('Error saving data:', error);
            }
        }

        document.getElementById('saveButton').addEventListener('click', saveData);

        socket.onopen = function(event) {
            console.log('WebSocket connection established');
            socket.send(JSON.stringify({ 'command': 'subscribe', 'group': 'web_clients_group' }));
        };                
// #endregion

// #region PeerConnection

        socket.onmessage = async function(event) {
            console.log('Received data from server');

            if (typeof event.data === "string") {
                const message = JSON.parse(event.data);

                if (!peerConnection) {
                    createPeerConnection();
                }

                if (message.type === 'offer') {
                    console.log('Received offer:', message.sdp);
                    if (peerConnection.signalingState !== 'stable' && peerConnection.signalingState !== 'have-remote-offer') {
                        console.error('Received offer in invalid state:', peerConnection.signalingState);
                        return;
                    }
                    await peerConnection.setRemoteDescription(new RTCSessionDescription({ type: 'offer', sdp: message.sdp }));
                    const answer = await peerConnection.createAnswer();
                    console.log("created answer for offer:",message.sdp);
                    await peerConnection.setLocalDescription(answer);
                    socket.send(JSON.stringify({ type: 'answer', sdp: answer.sdp }));
                } else if (message.type === 'ice') {
                    console.log('Received ICE candidate:', message.candidate);
                    const candidate = new RTCIceCandidate({ sdpMLineIndex: message.sdpMLineIndex, candidate: message.candidate });
                    await peerConnection.addIceCandidate(candidate);
                }
            } else if (event.data instanceof Blob) {
                const reader = new FileReader();
                reader.onload = function() {
                    const arrayBuffer = this.result;
                    const blob = new Blob([new Uint8Array(arrayBuffer)], { type: 'image/jpeg' });
                    const url = URL.createObjectURL(blob);
                    document.getElementById('streamImage').src = url;
                };
                reader.readAsArrayBuffer(event.data);
            }
        };

        function createPeerConnection() {
            peerConnection = new RTCPeerConnection(config);

            peerConnection.onicecandidate = function(event) {
                if (event.candidate) {
                    console.log('Sending ICE candidate:', event.candidate);
                    socket.send(JSON.stringify({ type: 'ice', candidate: event.candidate.candidate, sdpMid: event.candidate.sdpMid, sdpMLineIndex: event.candidate.sdpMLineIndex }));
                }
            };

            peerConnection.ontrack = function(event) {
                console.log('Track received:', event.track);
                document.getElementById('remoteAudio').srcObject = event.streams[0];
                document.getElementById('audioStatus').innerText = "Audio status: Connected";
            
                if (event.track.kind === 'audio') {
                    const audioStream = new MediaStream();
                    audioStream.addTrack(event.track);
                    remoteAudio.srcObject = audioStream;
                    event.track.enabled = true;
                    event.track.onmute = () => {
                        console.log('Track muted');
                    };
                    event.track.onunmute = () => {
                        console.log('Track unmuted');
                    };
                    console.log('Audio track received and set to play:', event.track);
                }
            };

            peerConnection.oniceconnectionstatechange = function() {
                console.log('ICE connection state change:', peerConnection.iceConnectionState);
            };

            peerConnection.onsignalingstatechange = function() {
                console.log('Signaling state change:', peerConnection.signalingState);
            };
        }

        socket.onerror = function(error) {
            console.error('WebSocket error:', error);
        };

        socket.onclose = function(event) {
            console.log('WebSocket connection closed:', event.code, event.reason);
        };

        window.addEventListener('beforeunload', () => {
            socket.close();
        });

        start(); // Start the process of requesting microphone access and initializing WebRTC
// #endregion
    </script>
</body>
</html>
